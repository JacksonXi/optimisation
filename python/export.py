# -*- coding: utf-8 -*-
"""export.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1qEw3NiQYFDTp0sMISqFOKYHeQXIC4-N3
"""

import shutil
import sys
import os.path
import numpy as np
import pandas as pd

if not shutil.which("pyomo"):
    !pip install -q pyomo
    assert(shutil.which("pyomo"))

if not (shutil.which("cbc") or os.path.isfile("cbc")):
    if "google.colab" in sys.modules:
        !apt-get install -y -qq coinor-cbc
    else:
        try:
            !conda install -c conda-forge coincbc 
        except:
            pass

assert(shutil.which("cbc") or os.path.isfile("cbc"))
    
from pyomo.environ import *

!git clone https://github.com/JacksonXi/optimisation

cd /content/optimisation/export

"""**Generated energy > (non-controlable energy + flexible energy)**

**Obtain consumer ID**
"""

Flexibleindex = pd.read_csv("flexibleIndex.csv")
Consumer1 = list(Flexibleindex['Unnamed: 0'])
Consumer = list(Flexibleindex['Unnamed: 0'])
Consumer

"""**Obtain flexibleindex during peak hours** 





**0: ON**


**1: OFF**



"""

flexibleindex = pd.read_csv("flexibleIndex.csv", index_col=0)
flexibleindex

"""**Obtain electrical usage (KWh)**"""

power = pd.read_csv('power.csv', index_col=0)
power

"""**Obtain power demand (non-controlable loads)**"""

demand = pd.read_csv('demand.csv', index_col=0)
print(demand)

"""**Obtain appliance type**"""

appliances = list(flexibleindex.keys())
appliances

"""**Obtain power demand (non-controlable loads and flexible loads)**"""

for c in Consumer:
    for a in appliances:
        demand['demand'][c] += power[a][c]*flexibleindex[a][c]
demand

"""**Obtain bid**"""

Consumer1

bid = pd.read_csv('bid.csv', index_col=0)
bid

"""**Sorting the bid**"""

n = len(bid)
consumer = [] 
while n != 0:
    max = Consumer[0]
    for i in range(0,n):
      if bid['bid'][max] < bid['bid'][Consumer[i]]:
          max = Consumer[i]
      else:
          max = max
    consumer.append(max)      
    Consumer.remove(max)
    n -= 1
print(Consumer)
print(consumer)

Rank = list(reversed(range(0, len(consumer))))
# Rank

consumer_rank = pd.DataFrame(list(zip(consumer, Rank)), columns =['Consumer', 'Rank'])
consumer_rank = consumer_rank.set_index('Consumer')
print(consumer_rank)

for c in consumer:
  consumer_rank['Rank'][c] += 1
consumer_rank

"""**Obtain prosumer ID**"""

generatedEnergy = pd.read_csv('generated energy.csv')
Prosumer = list(generatedEnergy['Unnamed: 0'])
Prosumer1 = list(generatedEnergy['Unnamed: 0'])
Prosumer

"""**Obtain generated energy in the community**"""

generated_energy = pd.read_csv('generated energy.csv', index_col=0)
generated_energy

"""**Sorting the storage energy**"""

n = len(generated_energy)
prosumer = [] 
while n != 0:
    max = Prosumer[0]
    for i in range(0,n):
      if generated_energy['generated energy'][max] < generated_energy['generated energy'][Prosumer[i]]:
          max = Prosumer[i]
      else:
          max = max
    prosumer.append(max)      
    Prosumer.remove(max)
    n -= 1
print(prosumer)
print(Prosumer)

Rank = list(reversed(range(0, len(prosumer))))

prosumer_rank = pd.DataFrame(list(zip(prosumer, Rank)), columns =['Prosumer', 'Rank'])
prosumer_rank = prosumer_rank.set_index('Prosumer')
print(prosumer_rank)

for p in prosumer:
  prosumer_rank['Rank'][p] += 1
prosumer_rank

"""**Energy is allocated in the order of the bid amount**"""

model = ConcreteModel()
model.dual = Suffix(direction=Suffix.IMPORT)

model.transport = Var(prosumer, consumer , domain = NonNegativeReals)


# model.revenue = Objective(expr = sum(model.transport[p, c]*bid['bid'][c] for c in consumer for p in prosumer), 
#                            sense = maximize)

model.revenue = Objective(expr = sum(model.transport[p, c]*bid['bid'][c]*(consumer_rank['Rank'][c])*(prosumer_rank['Rank'][p]) for c in consumer for p in prosumer), 
                           sense = maximize)

model.supply = ConstraintList()
for p in prosumer:
      model.supply.add(sum(model.transport[p, c] for c in consumer) <= generated_energy['generated energy'][p])

model.demand = ConstraintList()
for c in consumer:
      model.demand.add(sum(model.transport[p, c] for p in prosumer) <= demand['demand'][c])

results = SolverFactory('cbc').solve(model)
results.write()

model.pprint()

for p in prosumer:
    for c in consumer:
        print(p, c, model.transport[p,c]())

if 'ok' == str(results.Solver.status):
    print("Total Community Revenue = ",model.revenue())
    print("\nTransport Table:")
    for p in Prosumer1:
        for c in Consumer1:
            if model.transport[p,c]() > 0:
                print("Transport from ", p," to ", c, ":", model.transport[p,c](),'KWh')
else:
    print("No Valid Solution Found")

n = 0
if 'ok' == str(results.Solver.status):
    print("Personal Revenue:\n")
    for c in consumer:
        for p in prosumer:
            if model.transport[p,c]() > 0:
                print("Balance from ", c," to ", p, ":", model.transport[p,c]() * bid['bid'][c])
else:
    print("No Valid Solution Found")

n = 0
m = 0
if 'ok' == str(results.Solver.status):
    print("Personal Revenue:\n")
    for p in prosumer:
      for c in consumer:
          n += model.transport[p, c]() * bid['bid'][c] 
          m += model.transport[p, c]() * bid['bid'][c] 
      print("The revenue of",p ,":" , n)
      n = 0
else:
    print("No Valid Solution Found")
print('\nTotal revenue:',m)

n = 0
if 'ok' == str(results.Solver.status):
    print("The exported electricity to the grid:\n")
    for p in prosumer:
        n = generated_energy['generated energy'][p]
        for c in consumer:
            n -= model.transport[p, c]()
        if n > 0 :
            print(p, "will export ",n , "KWh to the grid")

n = 0
if 'ok' == str(results.Solver.status):
    print("Personal Revenue:\n")
    for c in Consumer1:
      for p in Prosumer1:
          n += model.transport[p, c]()
      print("The received energy of",c ,":" , n)
      n = 0
else:
    print("No Valid Solution Found")